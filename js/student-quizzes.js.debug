import API_CONFIG from './config.js';
import notifications from './utils/notifications.js';
import auth, { fetchWithTokenRefresh } from './utils/auth.js';

class QuizzesManager {
  constructor() {
    this.quizzesPerPage = 9
    this.currentPage = 1
    this.currentTab = "available"
    this.isLoading = false
    this.subjects = []
    this.filteredSubject = ""
    this.searchQuery = ""
    this.selectedQuiz = null
    this.showTestQuizzes = false

    // DOM Elements
    this.container = document.querySelector(".quiz-container")
    this.quizGrid = document.querySelector(".quiz-grid")
    this.pagination = document.querySelector(".pagination")
    this.tabs = document.querySelectorAll(".tab-btn")
    this.sectionTitle = document.querySelector(".section-title")
    this.logoutButton = document.querySelector(".logout-btn")
    this.searchInput = document.getElementById("quizSearch")
    this.subjectFilter = document.getElementById("subjectFilter")
    this.previewModal = document.getElementById("quizPreviewModal")
    this.closePreviewBtn = document.getElementById("closePreviewBtn")
    this.cancelQuizBtn = document.getElementById("cancelQuizBtn")
    this.startQuizBtn = document.getElementById("startQuizBtn")
    this.tabTitles = {
      available: "Available Quizzes",
      completed: "Completed Quizzes",
    }

    this.init()
  }

  async init() {
    try {
      this.setLoading(true)
      
      // Check URL parameters for completed or abandoned quiz
      const params = new URLSearchParams(window.location.search);
      const completedQuizId = params.get('completed');
      const abandonedQuizId = params.get('abandoned');
      
      // If there's a completed quiz or abandoned quiz, switch to the completed tab
      if (completedQuizId || abandonedQuizId) {
        this.currentTab = "completed";
        this.tabs.forEach(btn => {
          btn.classList.remove('active');
          if (btn.dataset.tab === 'completed') {
            btn.classList.add('active');
          }
        });
      }
      
      // First run a statistics update to ensure proper display (but don't block on errors)
      try {
        // Use direct fetch with proper path
        const response = await fetch(`/quizmaster/backend/student/update-statistics.php`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${auth.getToken()}`,
            'Cache-Control': 'no-store, no-cache, must-revalidate'
          },
          body: JSON.stringify({
            userId: auth.getUserId()
            // Removed forceUpdate to avoid potential server errors
          }),
          cache: 'no-store'
        });
        
        if (response.ok) {
          console.log("Applied statistics update successfully");
        } else {
          console.log(`Statistics update failed with status: ${response.status} - continuing without it`);
        }
      } catch (e) {
        console.log("Could not update statistics (continuing):", e.message);
      }
      
      // Load subject list first
      await this.loadSubjects()
      
      // Then load quizzes
      await this.loadQuizzes()
      
      // Setup UI event handlers
      this.setupUI()
      
      // Update the section title based on active tab
      this.sectionTitle.textContent = this.tabTitles[this.currentTab]
      
      // Check for completion message
      this.checkCompletionMessage()
      
    } catch (error) {
      console.error('Initialization error:', error);
      notifications.error('Failed to initialize quizzes. Please refresh the page or try again later.');
    } finally {
      this.setLoading(false);
    }
  }

  setupUI() {
    // Setup tab buttons
    this.tabs.forEach(button => {
      button.addEventListener('click', () => {
        this.currentTab = button.dataset.tab;
        this.currentPage = 1;
        
        // Update active tab button
        this.tabs.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        
        // Update section title to match the tab
        this.sectionTitle.textContent = this.tabTitles[this.currentTab];
        
        // Clear the current quizzes before loading
        this.quizGrid.innerHTML = '<div class="loading-indicator">Loading...</div>';
        
        // Force a statistics update before loading quizzes, but make it non-blocking
        // and use the correct path
        const timestamp = Date.now();
        fetch(`/quizmaster/backend/student/update-statistics.php?_t=${timestamp}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${auth.getToken()}`,
            'Cache-Control': 'no-store, no-cache, must-revalidate'
          },
          body: JSON.stringify({
            userId: auth.getUserId()
            // Removed forceUpdate and timestamp to simplify request
          }),
          cache: 'no-store'
        })
        .then((response) => {
          if (response.ok) {
            return response.text().then((text) => {
              try {
                // Try to parse as JSON if possible
                if (text && text.trim().startsWith('{')) {
                  return JSON.parse(text);
                }
                return { success: true };
              } catch(e) {
                console.log("Non-JSON response from statistics update (ignoring)");
                return { success: true };
              }
            }).then(() => {
              console.log("Applied statistics update before tab switch");
            });
          } else {
            console.log(`Statistics update skipped (status ${response.status}) - continuing`);
            return Promise.resolve();
          }
        })
        .catch(error => {
          console.log("Error updating statistics (continuing anyway):", error.message);
        })
        .finally(() => {
          // Add a small delay to ensure server-side processing completes
          setTimeout(() => {
            // Update state and load quizzes
            this.loadQuizzes();
          }, 300);
        });
      });
    });
    
    // Search input
    if (this.searchInput) {
      this.searchInput.addEventListener('input', this.debounce(() => {
        this.currentPage = 1;
        this.loadQuizzes();
      }, 500));
    }
    
    // Subject filter
    if (this.subjectFilter) {
      this.subjectFilter.addEventListener('change', () => {
        this.currentPage = 1;
        this.loadQuizzes();
      });
    }
    
    // Add test quizzes toggle to filters
    this.addTestQuizzesToggle();
    
    // Modal buttons
    if (this.closePreviewBtn) {
      this.closePreviewBtn.addEventListener("click", () => this.closePreviewModal())
    }
    
    if (this.cancelQuizBtn) {
      this.cancelQuizBtn.addEventListener("click", () => this.closePreviewModal())
    }
    
    if (this.startQuizBtn) {
      this.startQuizBtn.addEventListener("click", () => this.startQuiz())
    }

    // Add keyboard event for closing modal with Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && this.previewModal.classList.contains('active')) {
        this.closePreviewModal();
      }
    });
    
    // Close modal when clicking outside the modal content
    if (this.previewModal) {
      this.previewModal.addEventListener('click', (e) => {
        // If the click is directly on the modal background (not on its children)
        if (e.target === this.previewModal) {
          this.closePreviewModal();
        }
      });
    }

    // Add logout handler
    if (this.logoutButton) {
      this.logoutButton.addEventListener("click", () => this.handleLogout())
    }
  }

  // Add toggle for showing test quizzes
  addTestQuizzesToggle() {
    // Find the filter container
    const filtersContainer = document.querySelector('.filters') || document.querySelector('.filters-container');
    if (!filtersContainer) return;
    
    // Check if toggle already exists
    if (document.getElementById('testQuizzesToggle')) return;
    
    // Create toggle container
    const toggleContainer = document.createElement('div');
    toggleContainer.className = 'filter-item test-quizzes-toggle';
    
    // Create toggle checkbox
    const toggleCheckbox = document.createElement('input');
    toggleCheckbox.type = 'checkbox';
    toggleCheckbox.id = 'testQuizzesToggle';
    toggleCheckbox.checked = this.showTestQuizzes;
    
    // Create toggle label
    const toggleLabel = document.createElement('label');
    toggleLabel.htmlFor = 'testQuizzesToggle';
    toggleLabel.innerHTML = '<i class="fas fa-flask"></i> Show Test Quizzes';
    
    // Add elements to container
    toggleContainer.appendChild(toggleCheckbox);
    toggleContainer.appendChild(toggleLabel);
    
    // Add toggle to filters
    filtersContainer.appendChild(toggleContainer);
    
    // Add event listener
    toggleCheckbox.addEventListener('change', () => {
      this.showTestQuizzes = toggleCheckbox.checked;
      this.currentPage = 1;
      this.loadQuizzes();
      
      // Show message about test quizzes
      if (this.showTestQuizzes) {
        notifications.info('Test quizzes are now visible. These are for testing purposes only.');
      }
    });
  }

  async handleLogout() {
    try {
      // Clear any stored user data
      localStorage.removeItem("userToken")
      localStorage.removeItem("userData")

      // Redirect to login page
      window.location.href = "login.html"
    } catch (error) {
      console.error("Logout failed:", error)
    }
  }

  async loadSubjects() {
    try {
      console.log('Loading subjects using common/subjects.php');
      
      // Try multiple paths for subjects API
      let response = null;
      let error = null;
      
      // Paths to try in order
      const paths = [
        'common/subjects.php',
        'backendcommon/subjects',
        'common/subjects',
        'subjects.php'
      ];
      
      for (const path of paths) {
        try {
          console.log(`Attempting to load subjects from path: ${path}`);
          response = await fetchWithTokenRefresh(path, {
        method: 'GET',
            headers: { 'Content-Type': 'application/json' }
      });
          
          if (response.ok) {
            console.log(`Successfully loaded subjects from ${path}`);
            break;
          }
        } catch (err) {
          console.log(`Failed to load subjects from ${path}: ${err.message}`);
          error = err;
        }
      }
      
      if (!response || !response.ok) {
        throw error || new Error('Failed to fetch subjects from any path');
      }
      
      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.message || 'Failed to fetch subjects');
      }
      
      this.subjects = data.subjects || [];
      this.renderSubjectFilter();
      
    } catch (error) {
      console.error('Error loading subjects:', error);
      // We don't need to show an error message here as it's not critical
      this.subjects = []; // Set empty subjects
      this.renderSubjectFilter(); // Still render the filter
    }
  }

  renderSubjectFilter() {
    // Keep the default "All Subjects" option
    let options = '<option value="">All Subjects</option>';
    
    // Add options for each subject
    this.subjects.forEach(subject => {
      options += `<option value="${subject.id}">${subject.name}</option>`;
    });
    
    this.subjectFilter.innerHTML = options;
  }

  async loadQuizzes() {
      console.log("DEBUG: Loading quizzes...");
    if (this.isLoading) return;
    
    this.setLoading(true);
    
    try {
      // Skip the statistics update that's causing 500 errors
      
      // Generate a unique timestamp for cache busting
      const timestamp = new Date().getTime();
      
      const queryParams = new URLSearchParams({
        page: this.currentPage,
        type: this.currentTab,
        limit: this.quizzesPerPage,
        // Add a cache-busting timestamp
        _t: timestamp
      });

      // Only add user_id if we're actually logged in
      if (auth.getUserId()) {
        queryParams.append('user_id', auth.getUserId());
      }

      // Add search query if provided
      if (this.searchInput && this.searchInput.value.trim()) {
        this.searchQuery = this.searchInput.value.trim();
        queryParams.append('search', this.searchQuery);
      }

      // Add subject filter if selected
      if (this.subjectFilter && this.subjectFilter.value) {
        this.filteredSubject = this.subjectFilter.value;
        queryParams.append('subject', this.filteredSubject);
      }
      
      // Add test quizzes parameter if enabled
      if (this.showTestQuizzes) {
        queryParams.append('test', '1');
      }

      console.log("Fetching quizzes with parameters:", queryParams.toString());
      
      // Try multiple paths to ensure we find the quizzes.php file
      let response = null;
      let error = null;
      let foundData = false;
      
      // Create a response object with empty quizzes to start with
      const quizData = {
        quizzes: [],
        totalPages: 0,
        success: true,
        currentPage: this.currentPage
      };
      
      // First, try to get data from local storage if available
      try {
        const savedQuizzes = localStorage.getItem('studentQuizzes');
        if (savedQuizzes) {
          console.log("Found saved quizzes in local storage");
          const parsedQuizzes = JSON.parse(savedQuizzes);
          if (Array.isArray(parsedQuizzes) && parsedQuizzes.length > 0) {
            console.log("Using cached quizzes while fetching fresh data");
            quizData.quizzes = parsedQuizzes;
            quizData.totalPages = Math.ceil(parsedQuizzes.length / this.quizzesPerPage);
            
            // Render immediately with cached data
            console.log("DEBUG: About to render quizzes", quizData);
                this.renderQuizzes(quizData);
          }
        }
      } catch (e) {
        console.log("Error reading from local storage:", e.message);
      }
      
      // Attempt paths in priority order
      const paths = [
        // Try get endpoint first since we've fixed it
        '/quizmaster/backend/quiz/get.php',
        // Try student-specific endpoint next
        '/quizmaster/backend/student/quizzes.php',
        // Try search endpoint last
        '/quizmaster/backend/quiz/search.php'
      ];
      
      // Try each path in sequence
      for (const path of paths) {
        if (foundData) break; // Skip if we already found data
        
        try {
          console.log(`Trying quizzes path: ${path}`);
          
          response = await fetch(`${path}?${queryParams.toString()}`, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${auth.getToken()}`,
              'Cache-Control': 'no-store, no-cache, must-revalidate'
            },
            cache: 'no-store'
          });
          
          if (response.ok) {
            console.log(`Successfully connected to ${path}`);
              console.log(`DEBUG: Headers:`, Object.fromEntries([...response.headers]));
            
            // Try to get the response as binary first to check content type
            const contentType = response.headers.get('content-type');
            console.log(`Content-Type: ${contentType}`);
            
            // Skip binary responses
            if (contentType && (
                contentType.includes('application/octet-stream') || 
                contentType.includes('application/x-binary') ||
                contentType.includes('application/binary')
            )) {
              console.log(`Skipping binary response from ${path}`);
              continue;
            }
            
            // Try to parse the response as JSON
            try {
              const responseText = await response.text();
              
              // Check if we got non-JSON content by detecting typical non-JSON content
              if (responseText.includes('CREATE TABLE') || 
                  responseText.includes('<?php') ||
                  responseText.includes('<!DOCTYPE') ||
                  responseText.startsWith('') ||
                  responseText.startsWith('P')) {
                console.log(`Skipping non-JSON content from ${path}`);
                continue;
              }
              
              // Log response sample for debugging
              console.log(`Raw response (first 100 chars): ${responseText.substring(0, 100)}`);
              
              // Parse the JSON properly
              let data;
              try {
                data = JSON.parse(responseText);
              } catch (parseError) {
                console.log(`JSON parse error: ${parseError.message}`);
                
                // Try a more aggressive approach - look for the first '{' and last '}'
                const firstBrace = responseText.indexOf('{');
                const lastBrace = responseText.lastIndexOf('}');
                if (firstBrace >= 0 && lastBrace > firstBrace) {
                  try {
                    const cleanedJson = responseText.substring(firstBrace, lastBrace + 1);
                    console.log("Attempting with cleaned JSON:", cleanedJson.substring(0, 50));
                    data = JSON.parse(cleanedJson);
                  } catch (e) {
                    console.log("Failed with cleaned JSON too");
                    continue; // Move to next path
                  }
                } else {
                  continue; // Move to next path
                }
              }
              
              // Check if we have a valid quizzes array
              console.log("DEBUG: Checking data format", data);
              if (data && (Array.isArray(data.quizzes) || Array.isArray(data.results) || Array.isArray(data))) {
                console.log("Found valid quiz data");
                
                // Properly extract quizzes from the response structure
                if (data.quizzes) {
                  quizData.quizzes = data.quizzes;
                } else if (data.results) {
                  quizData.quizzes = data.results;
                } else if (Array.isArray(data)) {
                  quizData.quizzes = data;
                }
                
                // Get pagination data
                quizData.totalPages = data.totalPages || Math.ceil(quizData.quizzes.length / this.quizzesPerPage) || 1;
                quizData.currentPage = data.currentPage || this.currentPage;
                
                foundData = true;
                
                // Render with fresh data
                console.log("DEBUG: About to render quizzes", quizData);
                this.renderQuizzes(quizData);
                
                // Store in local storage for future fallback
                if (quizData.quizzes && quizData.quizzes.length > 0) {
                  localStorage.setItem('studentQuizzes', JSON.stringify(quizData.quizzes));
                  console.log("Stored quizzes in local storage for future use");
                }
                
                break; // Exit the loop once we have valid data
              }
            } catch (e) {
              console.log(`Response not valid JSON from ${path}: ${e.message}`);
              continue;
            }
          } else {
            console.log(`Failed to load quizzes from ${path}: ${response.status}`);
          }
        } catch (err) {
          console.log(`Error with path ${path}: ${err.message}`);
          error = err;
        }
      }
      
      // If we haven't found data and haven't rendered yet or need to update, render what we have
      if (!foundData) {
        if (quizData.quizzes.length > 0) {
          console.log("Using local storage quizzes as no fresh data was found");
          console.log("DEBUG: About to render quizzes", quizData);
                this.renderQuizzes(quizData);
        } else {
          console.log("No quiz data available");
          // Render empty state - this will show the empty state template in renderQuizzes
          this.renderQuizzes({ quizzes: [], totalPages: 0 });
          
          // Show notification
          notifications.info('No quiz data available. Please try again later or contact your instructor.');
        }
      }
      
    } catch (error) {
      this.handleError(error);
      // Make sure we still render an empty state
      this.renderQuizzes({ quizzes: [], totalPages: 0 });
    } finally {
      this.setLoading(false);
    }
  }

  async previewQuiz(quizId) {
    try {
      console.log(`Fetching preview data for quiz ID: ${quizId}`);
      
      // Try to find the quiz in our existing quizzes
      let quizData = null;
      
      // First try the API with multiple possible paths in correct order
      try {
        const paths = [
          // Prioritize the get.php endpoint
          '/quizmaster/backend/quiz/get.php',
          '/quizmaster/backend/student/quizzes.php',
          '/quizmaster/backend/quiz/search.php'
        ];
        
        let response = null;
        let foundData = false;
        
        for (const path of paths) {
          if (foundData) break;
          
          try {
            console.log(`Trying preview from path: ${path}`);
            
            // Add cache-busting parameter
            const timestamp = new Date().getTime();
            response = await fetch(`${path}?id=${quizId}&_t=${timestamp}`, {
              method: 'GET',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${auth.getToken()}`
              }
            });
            
            if (response.ok) {
              console.log(`Successfully loaded preview from ${path}`);
              
              // Try to handle potential invalid JSON response
              const responseText = await response.text();
              
              // Log first part of response for debugging
              console.log(`Raw preview response (first 50 chars): ${responseText.substring(0, 50)}`);
              
              // Find the start of the JSON if there might be PHP errors before it
              let jsonStart = responseText.indexOf('{');
              let jsonText;
              
              if (jsonStart >= 0) {
                jsonText = responseText.substring(jsonStart);
                console.log("Found JSON in preview response starting at position", jsonStart);
              } else {
                jsonText = responseText;
              }
              
              try {
                // Try to parse with error handling
                let data;
                try {
                  data = JSON.parse(jsonText);
                } catch (parseError) {
                  console.log(`JSON parse error in preview: ${parseError.message}`);
                  // Try a more aggressive approach - look for the first '{' and last '}'
                  const firstBrace = jsonText.indexOf('{');
                  const lastBrace = jsonText.lastIndexOf('}');
                  if (firstBrace >= 0 && lastBrace > firstBrace) {
                    try {
                      const cleanedJson = jsonText.substring(firstBrace, lastBrace + 1);
                      console.log("Attempting with cleaned JSON for preview:", cleanedJson.substring(0, 50));
                      data = JSON.parse(cleanedJson);
                    } catch (e) {
                      console.log("Failed with cleaned JSON too for preview");
                      continue; // Move to next path
                    }
                  } else {
                    continue; // Move to next path
                  }
                }
                
                // Check that we have valid data
                if (data && (data.success || data.id || (data.quizzes && data.quizzes.length))) {
                  if (data.quizzes && data.quizzes.length) {
                    // If we got a list of quizzes, find the one with matching ID
                    const matchingQuiz = data.quizzes.find(q => q.id == quizId);
                    if (matchingQuiz) {
                      quizData = matchingQuiz;
                      foundData = true;
                      break;
                    }
                  } else if (data.id) {
                    // If we got a single quiz directly
                    quizData = data;
                    foundData = true;
                    break;
                  } else if (data.success) {
                    // Extract quiz from successful response
                    quizData = data;
                    foundData = true;
                    break;
                  }
                }
              } catch (parseError) {
                console.log(`Error parsing JSON from ${path}:`, parseError.message);
              }
            } else {
              console.log(`Failed to load preview from ${path}: ${response.status}`);
            }
          } catch (fetchError) {
            console.log(`Request error with ${path}:`, fetchError.message);
          }
        }
      } catch (e) {
        console.log("Preview fetch attempt failed, will try fallbacks:", e.message);
      }
      
      // If API failed, try to find the quiz in local storage
      if (!quizData) {
        const savedQuizzes = localStorage.getItem('studentQuizzes');
        if (savedQuizzes) {
          try {
            const parsedQuizzes = JSON.parse(savedQuizzes);
            if (Array.isArray(parsedQuizzes)) {
              const quiz = parsedQuizzes.find(q => q.id == quizId);
              if (quiz) {
                quizData = quiz;
                console.log("Found quiz in local storage:", quiz);
              }
            }
          } catch (e) {
            console.log("Error retrieving saved quiz:", e.message);
          }
        }
      }
      
      // If we still don't have data, create a mock quiz
      if (!quizData) {
        console.log("Creating mock quiz data for preview");
        const mockQuiz = {
          id: quizId,
          title: "Demo Quiz",
          description: "This is a demo quiz created because the API server is unavailable.",
          subject: "General Knowledge",
          teacherName: "Demo Teacher",
          questionCount: 10,
          passingScore: 60,
          questionTypes: ['multiple_choice', 'true_false']
        };
        quizData = mockQuiz;
      }
      
      this.selectedQuiz = quizData;
      
      // Populate the modal with quiz details
      document.getElementById("previewQuizTitle").textContent = quizData.title;
      document.getElementById("previewTeacherName").textContent = quizData.teacherName || 'Unknown Teacher';
      document.getElementById("previewSubject").textContent = quizData.subject || 'General Subject';
      document.getElementById("previewQuestionCount").textContent = `${quizData.questionCount || 10} Questions`;
      
      // Set fixed time limit based on quiz configuration or default to 15 seconds per question
      const timeLimit = quizData.timeLimit || 15; // Default to 15 seconds per question
      document.getElementById("previewTimeLimit").textContent = `${timeLimit} Seconds Per Question`;
      
      // Ensure passing score is properly displayed
      const passingScore = quizData.passingScore || 60; // Default to 60% if not set
      document.getElementById("previewPassingScore").textContent = `${passingScore}% to Pass`;
      
      document.getElementById("previewDescription").textContent = quizData.description || 'No description available';

      // Display question types
      const questionTypesContainer = document.getElementById("previewQuestionTypes");
      questionTypesContainer.innerHTML = '';
      
      const questionTypes = this.getQuestionTypes(quizData.questionTypes);
      questionTypes.forEach(type => {
        const badge = document.createElement('span');
        badge.className = 'type-badge';
        badge.innerHTML = `
          <i class="fas ${this.getQuestionTypeIcon(type)}"></i>
          ${this.formatQuestionType(type)}
        `;
        questionTypesContainer.appendChild(badge);
      });

      // Show the modal
      this.previewModal.classList.add('active');
    } catch (error) {
      console.error('Error loading quiz details:', error);
      notifications.error('Failed to load quiz details. The server may be unavailable.');
    }
  }

  getQuestionTypes(typesData) {
    // If we receive an array of types, return it
    if (Array.isArray(typesData)) {
      return typesData;
    }
    
    // If we receive a string of comma-separated types
    if (typeof typesData === 'string') {
      return typesData.split(',').map(type => type.trim());
    }
    
    // If we don't have type data, return default types
    return ['multiple_choice', 'true_false', 'short_answer'];
  }

  getQuestionTypeIcon(type) {
    switch (type) {
      case 'multiple_choice':
        return 'fa-list-ul';
      case 'true_false':
        return 'fa-toggle-on';
      case 'short_answer':
        return 'fa-keyboard';
      default:
        return 'fa-question';
    }
  }

  formatQuestionType(type) {
    switch (type) {
      case 'multiple_choice':
        return 'Multiple Choice';
      case 'true_false':
        return 'True/False';
      case 'short_answer':
        return 'Short Answer';
      default:
        return type.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
    }
  }

  closePreviewModal() {
    this.previewModal.classList.remove('active');
    this.selectedQuiz = null;
  }

  startQuiz() {
    if (!this.selectedQuiz) return;
    
    // Check if this is a mock quiz (from our fallback system)
    const isMockQuiz = this.selectedQuiz.id >= 100 && this.selectedQuiz.id < 300; // Range used for mock quiz IDs
    
    if (isMockQuiz) {
      // Show message that real quiz-taking is unavailable
      this.closePreviewModal();
      notifications.info('Demo mode: Quiz taking is unavailable while the server is offline. Please try again when connectivity is restored.');
      return;
    }
    
    // For real quizzes, navigate to the quiz answer page
    window.location.href = `quiz-answer.html?id=${this.selectedQuiz.id}`;
  }

  renderQuizzes(data) {
    if (!data.quizzes || data.quizzes.length === 0) {
      let emptyMessage = '';
      
      if (this.currentTab === 'available') {
        emptyMessage = `
          <div class="empty-state">
            <i class="fas fa-search"></i>
            <h3>No available quizzes</h3>
            <p>There are no new quizzes available for you to take at this time.</p>
            <p>Check the "Completed Quizzes" tab to see quizzes you've already taken.</p>
          </div>
        `;
      } else {
        emptyMessage = `
          <div class="empty-state">
            <i class="fas fa-chart-bar"></i>
            <h3>No completed quizzes</h3>
            <p>You haven't completed any quizzes yet.</p>
            <p>Go to the "Available Quizzes" tab to take your first quiz!</p>
          </div>
        `;
      }
      
      this.quizGrid.innerHTML = emptyMessage;
      this.pagination.innerHTML = '';
      return;
    }
    
    this.quizGrid.innerHTML = data.quizzes.map(quiz => this.createQuizCard(quiz)).join("");
    
    // Add event listeners to the quiz cards and buttons
    const answerButtons = document.querySelectorAll('.answer-btn');
    answerButtons.forEach(button => {
      button.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent triggering card click
        const quizId = button.getAttribute('data-quiz-id');
        this.previewQuiz(quizId);
      });
    });
    
    // Add click event to entire card for available quizzes
    const quizCards = document.querySelectorAll('.quiz-card:not(.completed)');
    quizCards.forEach(card => {
      card.addEventListener('click', () => {
        const quizId = card.getAttribute('data-quiz-id');
        this.previewQuiz(quizId);
      });
    });
    
    this.updatePagination(data.totalPages);
  }

  createQuizCard(quiz) {
    // Process the avatar path to ensure it works correctly
    let avatarSrc = quiz.teacherAvatar || "images/profile-placeholder.svg";
    
    // Add the /quizmaster prefix if it's not already there and it's not an absolute URL
    if (avatarSrc && !avatarSrc.startsWith('http') && !avatarSrc.startsWith('/quizmaster/')) {
      // If it already starts with a slash, just add the prefix
      if (avatarSrc.startsWith('/')) {
        avatarSrc = '/quizmaster' + avatarSrc;
      } else {
        // Otherwise add the prefix with a slash
        avatarSrc = '/quizmaster/' + avatarSrc;
      }
    }
    
    const questionTypesBadges = this.getQuizTypesBadges(quiz);

    // Prepare image position and scale attributes
    let imagePositionStyles = '';
    if (typeof quiz.teacher_image_position_x === 'number' &&
        typeof quiz.teacher_image_position_y === 'number' &&
        typeof quiz.teacher_image_scale === 'number') {
      
      const posX = Number(quiz.teacher_image_position_x);
      const posY = Number(quiz.teacher_image_position_y);
      const scale = parseFloat(quiz.teacher_image_scale);
      
      imagePositionStyles = `object-fit: cover; object-position: ${posX}px ${posY}px; transform: scale(${scale}); transform-origin: center center; will-change: transform, object-position;`;
      
      console.log(`Applied image position to teacher avatar: x=${posX}, y=${posY}, scale=${scale}`);
    }

    if (this.currentTab === "available") {
      return `
        <div class="quiz-card" data-quiz-id="${quiz.id}">
          <div class="teacher-info">
            <img src="${avatarSrc}" alt="${quiz.teacherName}" class="teacher-avatar"
                 style="${imagePositionStyles}"
                 onerror="this.src='/quizmaster/frontend/images/profile-placeholder.svg'">
            <div class="teacher-details">
              <div class="teacher-name">${quiz.teacherName}</div>
              <div class="subject">${quiz.subject}</div>
            </div>
          </div>
          <div class="quiz-content">
            <h3 class="quiz-title">${quiz.title}</h3>
            <p class="quiz-description">${this.truncateText(quiz.description, 120)}</p>
            ${questionTypesBadges}
          </div>
          <button class="answer-btn" data-quiz-id="${quiz.id}">
            <i class="fas fa-play"></i>
            <span>Take Quiz</span>
          </button>
        </div>
      `;
    } else {
      // Format completed date
      const completedDate = new Date(quiz.completedDate).toLocaleDateString();
      
      // Debug logging for isCorrect value
      console.log(`Quiz ${quiz.id}: score=${quiz.score}, passingScore=${quiz.passingScore}`);
      
      // Directly compare score with passing score to determine if passed
      const score = parseInt(quiz.score || 0);
      const passingScore = parseInt(quiz.passingScore || 60);
      const isPassed = score >= passingScore;
      
      const statusClass = isPassed ? "correct" : "wrong";
      const statusText = isPassed ? "Passed" : "Failed";
      
      return `
        <div class="quiz-card completed" data-quiz-id="${quiz.id}">
          <div class="teacher-info">
            <img src="${avatarSrc}" alt="${quiz.teacherName}" class="teacher-avatar"
                 style="${imagePositionStyles}"
                 onerror="this.src='/quizmaster/frontend/images/profile-placeholder.svg'">
            <div class="teacher-details">
              <div class="teacher-name">${quiz.teacherName}</div>
              <div class="subject">${quiz.subject}</div>
            </div>
          </div>
          <div class="quiz-content">
            <h3 class="quiz-title">${quiz.title}</h3>
            <p class="quiz-description">${this.truncateText(quiz.description, 100)}</p>
          </div>
          <div class="quiz-status">
            <span class="status-badge ${statusClass}">
              ${statusText}
            </span>
            <span class="score-display">${quiz.score || 0}%</span>
            <span class="completed-date">${completedDate}</span>
          </div>
        </div>
      `;
    }
  }

  getQuizTypesBadges(quiz) {
    if (!quiz.questionTypes) return '';
    
    const types = this.getQuestionTypes(quiz.questionTypes);
    
    if (types.length === 0) return '';
    
    let badges = '<div class="question-type-badges">';
    
    types.forEach(type => {
      badges += `
        <span class="type-indicator" title="${this.formatQuestionType(type)}">
          <i class="fas ${this.getQuestionTypeIcon(type)}"></i>
        </span>
      `;
    });
    
    badges += '</div>';
    return badges;
  }

  truncateText(text, maxLength) {
    if (!text) return '';
    return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
  }

  updatePagination(totalPages) {
    if (totalPages <= 1) {
      this.pagination.innerHTML = '';
      return;
    }
    
    let html = `
      <button class="page-button prev" ${this.currentPage === 1 ? "disabled" : ""}>
        <i class="fas fa-chevron-left"></i>
      </button>
    `;

    for (let i = 1; i <= totalPages; i++) {
      if (i === 1 || i === totalPages || (i >= this.currentPage - 1 && i <= this.currentPage + 1)) {
        html += `
          <button class="page-button ${i === this.currentPage ? "active" : ""}" data-page="${i}">${i}</button>
        `;
      } else if (i === this.currentPage - 2 || i === this.currentPage + 2) {
        html += `<span class="page-ellipsis">...</span>`;
      }
    }

    html += `
      <button class="page-button next" ${this.currentPage === totalPages ? "disabled" : ""}>
        <i class="fas fa-chevron-right"></i>
      </button>
    `;

    this.pagination.innerHTML = html;
    
    // Add event listeners to pagination buttons
    const pageButtons = this.pagination.querySelectorAll('.page-button[data-page]');
    pageButtons.forEach(button => {
      button.addEventListener('click', () => {
        const page = parseInt(button.getAttribute('data-page'));
        this.navigateToPage(page);
      });
    });
    
    // Add event listeners for prev/next buttons
    const prevButton = this.pagination.querySelector('.page-button.prev');
    if (prevButton && !prevButton.disabled) {
      prevButton.addEventListener('click', () => {
        this.navigateToPage(this.currentPage - 1);
      });
    }
    
    const nextButton = this.pagination.querySelector('.page-button.next');
    if (nextButton && !nextButton.disabled) {
      nextButton.addEventListener('click', () => {
        this.navigateToPage(this.currentPage + 1);
      });
    }
  }

  async navigateToPage(page) {
    if (page === this.currentPage || this.isLoading) return;
    this.currentPage = page;
    await this.loadQuizzes();
  }

  /**
   * Set loading state
   * @param {boolean} isLoading 
   */
  setLoading(isLoading) {
    const loader = document.getElementById('loader');
    if (loader) {
      loader.style.display = isLoading ? 'flex' : 'none';
    }
    
    if (this.quizzesContainer) {
      this.quizzesContainer.style.opacity = isLoading ? '0.5' : '1';
    }
  }

  handleError(error) {
    console.error("Error:", error);
    
    // For 404 and 500 errors related to quizzes.php and update-statistics.php,
    // we're already handling those with fallbacks, so don't show error messages
    if (error.message && (
        error.message.includes("quizzes.php") || 
        error.message.includes("update-statistics.php") ||
        error.message.includes("404") ||
        error.message.includes("500"))) {
      console.log("Error already handled with fallbacks");
      return;
    }
    
    // Determine a more specific error message based on the error
    let errorMessage = error.message || "An error occurred";
    
    if (errorMessage.includes("Failed to fetch") || errorMessage.includes("NetworkError")) {
      errorMessage = "Network error: Using demo data while offline.";
      
      // No need for additional API calls since we're clearly offline
      notifications.warning(errorMessage);
      return;
    } else if (errorMessage.includes("Invalid response") || errorMessage.includes("parse JSON")) {
      errorMessage = "Server returned an invalid response. Using demo data instead.";
      notifications.warning(errorMessage);
      return;
    } else if (errorMessage.includes("Unauthorized") || errorMessage.includes("expired")) {
      // Try to refresh the token first
      auth.refreshToken().then(success => {
        if (success) {
          // Token refreshed successfully, retry the operation
          notifications.info("Session renewed. Reloading data...");
          this.loadQuizzes();
        } else {
          // Token refresh failed, redirect to login
          errorMessage = "Your session has expired. Please log in again.";
          notifications.error(errorMessage);
          setTimeout(() => {
            auth.logout();
          }, 2000);
        }
      });
      return;
    }
    
    // Only show error for non-fallback issues
    notifications.error(errorMessage);
  }
  
  // Check URL parameters for quiz completion or abandonment
  checkCompletionMessage() {
    // Check URL parameters for status messages
    const params = new URLSearchParams(window.location.search);
    const completedQuizId = params.get('completed');
    const abandonedQuizId = params.get('abandoned');
    
    // Clean URL parameters to prevent showing the message again on refresh
    if (completedQuizId || abandonedQuizId) {
      const newUrl = new URL(window.location.href);
      if (completedQuizId) newUrl.searchParams.delete('completed');
      if (abandonedQuizId) newUrl.searchParams.delete('abandoned');
      window.history.replaceState({}, document.title, newUrl.toString());
            
      // Show appropriate message
      if (completedQuizId) {
      notifications.success('Quiz completed! Your results have been saved.');
      this.forceDatabaseRefreshAfterQuizCompletion(completedQuizId);
      } 
      
      if (abandonedQuizId) {
        notifications.error('Quiz abandoned. This attempt has been marked as failed.');
        this.forceDatabaseRefreshAfterQuizCompletion(abandonedQuizId);
        
        // Switch to the completed tab to show the failed quiz
        this.tabs.forEach(btn => {
          if (btn.dataset.tab === 'completed') {
            btn.click();
          }
        });
      }
    }
  }
  
  // Force database refresh after a quiz completion without trying broken endpoints
  async forceDatabaseRefreshAfterQuizCompletion(quizId) {
    console.log(`Updating local data after completing quiz ID: ${quizId}`);
    
    try {
      // Skip server update and just update locally
      console.log("Skipping server update due to 500 errors");
      
      // Add a small delay
      await new Promise(resolve => setTimeout(resolve, 300));
      
      // Reload quizzes without full page reload
      await this.loadQuizzes();
    } catch (error) {
      console.error("Error refreshing after quiz completion:", error);
      this.loadQuizzes();
    }
  }
  
  // Special method to force a complete database cleanup and reload quizzes
  async forceCleanupAndLoadQuizzes() {
    this.setLoading(true);
    
    try {
      console.log("Skipping server update due to 500 errors");
      
      // Switch to completed tab if needed
      if (this.currentTab !== 'completed') {
        // Find and click the completed tab button
        this.tabs.forEach(btn => {
          if (btn.dataset.tab === 'completed') {
            btn.classList.add('active');
            this.tabs.forEach(otherBtn => {
              if (otherBtn !== btn) otherBtn.classList.remove('active');
            });
            this.currentTab = 'completed';
          }
        });
      }
      
      // Add a small delay to ensure UI updates
      await new Promise(resolve => setTimeout(resolve, 300));
      
      // Load quizzes with fresh timestamp
      await this.loadQuizzes();
      
    } catch (error) {
      console.log("Error during cleanup:", error.message);
      this.loadQuizzes(); // Still try to load quizzes
    } finally {
      this.setLoading(false);
    }
  }

  // Simple debounce function
  debounce(func, wait) {
    let timeout;
    return function(...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }

  // Generate mock quiz data for demonstration when API is unavailable
  generateMockQuizzes() {
    console.log("Mock data generation disabled");
    return []; // Return empty array instead of mock data
  }

  async loadQuizDetails(quizId) {
    try {
      const token = auth.getToken();
      if (!token) {
        throw new Error('Authentication required');
      }

      // Try to load quiz details from the API
      const response = await fetch(`/quizmaster/backend/quiz/get.php?id=${quizId}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        }
      });

      // Check if the response is valid
      if (!response.ok) {
        throw new Error(`Failed to load quiz details: ${response.status} ${response.statusText}`);
      }

      // Check the content type to avoid parsing non-JSON responses
      const contentType = response.headers.get('Content-Type');
      if (!contentType || !contentType.includes('application/json')) {
        console.warn(`Unexpected content type: ${contentType}`);
        throw new Error('Invalid response format');
      }

      const data = await response.json();
      if (!data.success) {
        throw new Error(data.error || 'Failed to load quiz details');
      }

      return data.quiz;
    } catch (error) {
      console.error('Error loading quiz details:', error);
      throw error;
    }
  }

  async openQuizDetails(quizId) {
    try {
      this.setLoading(true);
      const quizDetails = await this.loadQuizDetails(quizId);
      
      // Store the quiz details in local storage for the quiz page to use
      localStorage.setItem('current_quiz', JSON.stringify(quizDetails));
      
      // Navigate to the quiz details page
      window.location.href = 'quiz-details.html?id=' + quizId;
    } catch (error) {
      console.error('Failed to open quiz details:', error);
      this.showError('Failed to load quiz details. Please try again later.');
      this.setLoading(false);
    }
  }
}

// Initialize when DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
  // Debug token information
  const token = localStorage.getItem('userToken');
  if (token) {
    try {
      const parts = token.split('.');
      if (parts.length === 3) {
        const payload = JSON.parse(atob(parts[1]));
        console.log('Token payload:', payload);
      }
    } catch (e) {
      console.error('Error parsing token:', e);
    }
  }
  
  // Initialize manager
  const quizzesManager = new QuizzesManager();
});
